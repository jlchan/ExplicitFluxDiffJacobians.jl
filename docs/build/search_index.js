var documenterSearchIndex = {"docs":
[{"location":"#FluxDiffUtils-Documentation","page":"Home","title":"FluxDiffUtils Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"@includedocs.md","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Functions","page":"Home","title":"Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [FluxDiffUtils]","category":"page"},{"location":"#FluxDiffUtils.banded_function_evals!-Union{Tuple{Fxn}, Tuple{Any,Fxn,Any,Vararg{Any,N} where N}} where Fxn","page":"Home","title":"FluxDiffUtils.banded_function_evals!","text":"banded_function_evals!(A,mat_fun::Fxn, U, Fargs ...) where Fxn\n\nMutating version of banded_function_evals.\n\n\n\n\n\n","category":"method"},{"location":"#FluxDiffUtils.banded_function_evals-Union{Tuple{Fxn}, Tuple{Fxn,Any,Vararg{Any,N} where N}} where Fxn","page":"Home","title":"FluxDiffUtils.banded_function_evals","text":"banded_function_evals(mat_fun::Fxn, U, Fargs...)\n\nComputes block-banded matrix whose bands are entries of matrix-valued function evals (e.g., a Jacobian). Returns SMatrix whose blocks correspond to function components evaluated at values of U.\n\nExample:\n\njulia> mat_fun(U) = [U[1] U[2]; U[2] U[1]]\njulia> U = (randn(10),randn(10))\njulia> banded_function_evals(mat_fun,U)\n\n\n\n\n\n","category":"method"},{"location":"#FluxDiffUtils.hadamard_jacobian!-Union{Tuple{Fxn}, Tuple{Nd}, Tuple{N}, Tuple{StaticArrays.SArray{Tuple{N,N},T,2,L} where L where T,Tuple{Vararg{AbstractArray,Nd}},Symbol,Fxn,Any,Vararg{Any,N} where N}} where Fxn where Nd where N","page":"Home","title":"FluxDiffUtils.hadamard_jacobian!","text":"hadamard_jacobian!(A::SMatrix{N,N},\n                   A_list::NTuple{Nd,AbstractArray},\n                   hadamard_product_type::Symbol, dF::Fxn, U,\n                   Fargs...; skip_index=(i,j)->false) where {N,Nd,Fxn}\n\nMutating version of hadamard_jacobian. A = matrix for storing Jacobian output, with each entry storing a block of the Jacobian.\n\n\n\n\n\n","category":"method"},{"location":"#FluxDiffUtils.hadamard_jacobian-Union{Tuple{Fxn}, Tuple{N}, Tuple{Any,Any,Fxn,Any,Vararg{Any,N} where N}} where Fxn where N","page":"Home","title":"FluxDiffUtils.hadamard_jacobian","text":"hadamard_jacobian(A_list, dF::Fxn, U, Fargs...;\n                  skip_index=(i,j)->false) where {N,Fxn}\n\nhadamard_jacobian(A_list, hadamard_product_type, dF::Fxn, U,\n                  Fargs...; skip_index=(i,j)->false) where {N,Fxn}\n\nComputes Jacobian of the flux differencing term ∑_i sum(Ai.*Fi). Outputs array whose entries are blocks of the Jacobian matrix corresponding to components of flux vectors.\n\nInputs:\n\nA_list = tuple of operators\n(optional) hadamard_product_type = :skew, :sym. Specifies if Ai.*Fi is skew or symmetric.\ndF = Jacobian of the flux function F(uL,uR) with respect to uR\nU = solution at which to evaluate the Jacobian\nFargs = extra args for dF(uL,uR)\n(optional) skip_index(i,j) = optional function to skip computation of (i,j)th entry\n\n\n\n\n\n","category":"method"},{"location":"#FluxDiffUtils.hadamard_sum!-Union{Tuple{Fxn}, Tuple{T}, Tuple{N}, Tuple{Any,Tuple{Vararg{T,N}},Fxn,Any,Vararg{Any,N} where N}} where Fxn where T where N","page":"Home","title":"FluxDiffUtils.hadamard_sum!","text":"hadamard_sum!(rhs, A_list::NTuple{N,T}, F::Fxn, u, Fargs...;\n             skip_index=(i,j)->false) where {N,T,Fxn}\n\nMutating version of hadamard_sum, where rhs is storage for output.\n\n\n\n\n\n","category":"method"},{"location":"#FluxDiffUtils.hadamard_sum-Union{Tuple{Fxn}, Tuple{T}, Tuple{N}, Tuple{Tuple{Vararg{T,N}},Fxn,Any,Vararg{Any,N} where N}} where Fxn where T where N","page":"Home","title":"FluxDiffUtils.hadamard_sum","text":"hadamard_sum(A_list::NTuple{N,T}, F::Fxn, u, Fargs...;\n             skip_index=(i,j)->false) where {N,T,Fxn}\n\ncomputes ∑i sum(Ai.*Fi,dims=2) where (Fi)jk = F(uj,uk)[i]\n\nInputs\n\nA_list: tuple of operators (A1,...,Ad)\nF: flux function which outputs a d-tuple of flux vectors\nu: collection of solution values (or arrays) at which to evaluate F\nFargs: extra arguments to F(ui,getindex.(Fargs,i)...,                           uj,getindex.(Fargs,j)...)`\n(optional) skip_index(i,j)==true skips computing fluxes for index (i,j)\n\n\n\n\n\n","category":"method"},{"location":"docs/","page":"-","title":"-","text":"This package provides utilities for flux differencing and computation of flux differencing Jacobians in terms of derivatives of flux functions. The code based in part on the preprint \"Efficient computation of Jacobian matrices for entropy stable summation-by-parts schemes\".","category":"page"},{"location":"docs/","page":"-","title":"-","text":"The routines are meant to be fairly general, but specialize depending on whether the operators are general arrays or SparseMatrixCSC (to capitalize on sparsity).","category":"page"},{"location":"docs/#Example","page":"-","title":"Example","text":"","category":"section"},{"location":"docs/","page":"-","title":"-","text":"using LinearAlgebra\nusing FluxDiffUtils\nusing Test\n\n# make 3-field solution\nu = collect(LinRange(-1,1,4))\nU = (u,u,u)\n\navg(x,y) = @. .5*(x+y)\nfunction flux(UL,UR)\n    uL,vL,wL = UL\n    uR,vR,wR = UR\n    Fx = avg(uL,uR),avg(vL,vR),avg(wL,wR)\n    Fy = avg(uL,uR),avg(vL,vR),avg(wL,wR)\n    return SVector{3}(Fx),SVector{3}(Fy)\nend\n\n# jacobians w.r.t. (uR,vR)\ndf(uL,vL,uR,vR) = ([.5 0 0; 0 .5 0; 0 0 .5], [.5 0 0; 0 .5 0; 0 0 .5])\nA_list = (A->A+A').(ntuple(x->randn(4,4),2)) # make symmetric to check formula\n\nrhs = hadamard_sum(A_list,flux,U)\n\njac = hadamard_jacobian(A_list, df, U)\n# jac = hadamard_jacobian(A_list, :sym, df, U) # optimized version\n\njac11_exact = sum((A->.5*(A + diagm(vec(sum(A,dims=1))))).(A_list))\n@test norm(jac11_exact-jac[1,1]) < 1e-12\n\n# converts tuple-block storage of jac to a global matrix\njac_global = hvcat(size(jac,1),jac...)","category":"page"},{"location":"docs/#Conventions","page":"-","title":"Conventions","text":"","category":"section"},{"location":"docs/","page":"-","title":"-","text":"We assume grouped arguments for both fluxes and derivatives (e.g., FluxDiffUtils.jl expects fluxes of the form  f(U,V) instead of f(u1,u2,v1,v2) for U=(u1,u2), V=(v1,v2)).\nWe assume the number of outputs from the flux matches the number of operators passed in. In other words, if f(uL,vL) has 2 outputs g,h, you should provide matrices (A1, A2). hadamard_sum will compute sum(A1.*g + A2.*h, dims = 2) (hadamard_jacobian behaves similarly).\nFor Jacobian matrices, we assume derivatives of flux functions f(uL,uR) are taken with respect to the second argument uR.\nJacobians are returned as a StaticArray of arrays, and can be concatenated into a global matrix using hvcat(size(jac,1),jac...).\nJacobian computations can be made more efficient by specifying if the Hadamard product A.*F (where A is a discretization matrix and F is a flux matrix) is symmetric or skew-symmetric by setting hadamard_product_type to :sym or :skew. Otherwise, FluxDiffUtils.jl will split the matrix A into skew and symmetric parts and compute Jacobians for each.","category":"page"}]
}
