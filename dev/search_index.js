var documenterSearchIndex = {"docs":
[{"location":"#FluxDiffUtils-Documentation","page":"Home","title":"FluxDiffUtils Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides utilities for flux differencing and computation of flux differencing Jacobians in terms of derivatives of flux functions. The code based in part on the preprint \"Efficient computation of Jacobian matrices for entropy stable summation-by-parts schemes\".","category":"page"},{"location":"","page":"Home","title":"Home","text":"The routines are meant to be fairly general, but specialize depending on whether the operators are general arrays or SparseMatrixCSC (to capitalize on sparsity).","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using LinearAlgebra\nusing FluxDiffUtils\nusing Test\n\n# make 3-field solution\nu = collect(LinRange(-1,1,4))\nU = (u,u,u)\n\n# define a flux fS\navg(x,y) = @. .5*(x+y)\nfunction fS(UL,UR)\n    uL,vL,wL = UL\n    uR,vR,wR = UR\n    Fx = avg(uL,uR),avg(vL,vR),avg(wL,wR)\n    Fy = avg(uL,uR),avg(vL,vR),avg(wL,wR)\n    return SVector{3}(Fx),SVector{3}(Fy)\nend\n\n# jacobians w.r.t. (uR,vR)\ndfS(UL,UR) = ([.5 0 0; 0 .5 0; 0 0 .5], [.5 0 0; 0 .5 0; 0 0 .5])\nA_list = (A->A+A').(ntuple(x->randn(4,4),2)) # make symmetric to check formula\n\nrhs = hadamard_sum(A_list,fS,U)\n\njac = hadamard_jacobian(A_list, dfS, U)\n# jac = hadamard_jacobian(A_list, :sym, df, U) # optimized version\n\njac11_exact = sum((A->.5*(A + diagm(vec(sum(A,dims=1))))).(A_list))\n@test norm(jac11_exact-jac[1,1]) < 1e-12\n\n# converts tuple-block storage of jac to a global matrix\njac_global = blockcat(size(jac,2),jac)","category":"page"},{"location":"#Conventions","page":"Home","title":"Conventions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We assume grouped arguments for both fluxes and derivatives (e.g., FluxDiffUtils.jl expects fluxes of the form  f(U,V) instead of f(u1,u2,v1,v2) for U=(u1,u2), V=(v1,v2)).\nWe assume the number of outputs from the flux matches the number of operators passed in. In other words, if f(uL,vL) has 2 outputs g,h, you should provide two matrices (A1, A2). hadamard_sum will compute sum(A1.*g + A2.*h, dims = 2) (hadamard_jacobian behaves similarly).\nFor Jacobian matrices, we assume derivatives of flux functions f(uL,uR) are taken with respect to the second argument uR.\nJacobians are returned as a StaticArray of arrays, and can be concatenated into a global matrix using blockcat(size(jac,2),jac). This assumes an ordering of degrees of freedom by fields first (e.g., [u1, u2, ..., uN, v1, v2, ..., vN, w1, w2, ..., wN] rather than [u1,v1,w1, u2,v2,w2, ...])\nJacobian computations can be made more efficient by specifying if the Hadamard product A.*F (where A is a discretization matrix and F is a flux matrix) is symmetric or skew-symmetric by setting hadamard_product_type to :sym or :skew. Otherwise, FluxDiffUtils.jl will split the matrix A into skew and symmetric parts and compute Jacobians for each.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Functions","page":"Home","title":"Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [FluxDiffUtils]","category":"page"},{"location":"#FluxDiffUtils.TupleOrSVector","page":"Home","title":"FluxDiffUtils.TupleOrSVector","text":"TupleOrSVector{N}\n\nEither a NTuple or SVector (e.g., fast static container) of length N.\n\n\n\n\n\n","category":"type"},{"location":"#FluxDiffUtils.banded_function_evals!-Union{Tuple{Fxn}, Tuple{Any,Fxn,Any,Vararg{Any,N} where N}} where Fxn","page":"Home","title":"FluxDiffUtils.banded_function_evals!","text":"banded_function_evals!(A,mat_fun::Fxn, U, Fargs ...) where Fxn\n\nMutating version of banded_function_evals.\n\n\n\n\n\n","category":"method"},{"location":"#FluxDiffUtils.banded_function_evals-Union{Tuple{Fxn}, Tuple{Fxn,Any,Vararg{Any,N} where N}} where Fxn","page":"Home","title":"FluxDiffUtils.banded_function_evals","text":"banded_function_evals(mat_fun::Fxn, U, Fargs...)\n\nComputes block-banded matrix whose bands are entries of matrix-valued function evals (e.g., a Jacobian). Returns SMatrix whose blocks correspond to function components evaluated at values of U.\n\nExample:\n\njulia> mat_fun(U) = [U[1] U[2]; U[2] U[1]]\njulia> U = (randn(10),randn(10))\njulia> banded_function_evals(mat_fun,U)\n\n\n\n\n\n","category":"method"},{"location":"#FluxDiffUtils.blockcat-Tuple{Any,Any}","page":"Home","title":"FluxDiffUtils.blockcat","text":"blockcat(n, A)\nblockcat(n, A::AbstractMatrix{SparseMatrixCSC{Ti,Tv}}) where {Ti,Tv}\n\nConcatenates the n-by-n matrix of matrices A into a global matrix. If eltype(A) = SparseMatrixCSC, blockcat returns a global sparse matrix. Otherwise, blockcat returns a global dense array of type Array{eltype(first(A))}.\n\n\n\n\n\n","category":"method"},{"location":"#FluxDiffUtils.hadamard_jacobian!-Union{Tuple{Nfields}, Tuple{Fxn}, Tuple{StaticArrays.SArray{Tuple{Nfields,Nfields},T,2,L} where L where T,Any,Symbol,Fxn,Any,Vararg{Any,N} where N}} where Nfields where Fxn","page":"Home","title":"FluxDiffUtils.hadamard_jacobian!","text":"hadamard_jacobian!(A::SMatrix{N,N},A_list,hadamard_product_type::Symbol,\n                   dF::Fxn,U,Fargs...; skip_index=(i,j)->false) where {N,Nd,Fxn}\n\nMutating version of hadamard_jacobian. A = matrix for storing Jacobian output, with each entry storing a block of the Jacobian.\n\n\n\n\n\n","category":"method"},{"location":"#FluxDiffUtils.hadamard_jacobian-Union{Tuple{Fxn}, Tuple{N}, Tuple{Any,Fxn,Any,Vararg{Any,N} where N}} where Fxn where N","page":"Home","title":"FluxDiffUtils.hadamard_jacobian","text":"hadamard_jacobian(A_list, dF::Fxn, U, Fargs...;\n                  skip_index=(i,j)->false) where {N,Fxn}\nhadamard_jacobian(A_list, hadamard_product_type, dF::Fxn, U,\n                  Fargs...; skip_index=(i,j)->false) where {N,Fxn}\n\nComputes Jacobian of the flux differencing term ∑_i sum(Ai.*Fi). Outputs array whose entries are blocks of the Jacobian matrix corresponding to components of flux vectors.\n\nInputs:\n\nA_list = tuple of operators\nhadamard_product_type = :skew, :sym. Specifies if Ai.*Fi is skew or symmetric.\ndF = Jacobian of the flux function F(uL,uR) with respect to uR\nU = solution at which to evaluate the Jacobian\nFargs = extra args for dF(uL,uR)\n(optional) skip_index(i,j) = optional function to skip computation of (i,j)th entry\n\n\n\n\n\n","category":"method"},{"location":"#FluxDiffUtils.hadamard_sum-Union{Tuple{Fxn}, Tuple{Any,Fxn,Any,Vararg{Any,N} where N}} where Fxn","page":"Home","title":"FluxDiffUtils.hadamard_sum","text":"hadamard_sum(A_list, F::Fxn, u, Fargs...;\n             skip_index=(i,j)->false) where {N,T,Fxn}\n\ncomputes ∑i sum(Ai.*Fi,dims=2) where (Fi)jk = F(uj,uk)[i]\n\nInputs\n\nA_list: tuple (or similar container) of operators (A1,...,Ad)\nF: flux function which outputs a length d container of flux vectors\nu: collection of solution values (or arrays) at which to evaluate F\nFargs: extra arguments to F(ui,uj,getindex.(Fargs,i)...,getindex.(Fargs,j)...)\n(optional) skip_index(i,j)==true skips computing fluxes for index (i,j)\n\nSince this sums over rows of matrices, this function may be slow for column-major and sparse CSC matrices. If you are using column major/CSC storage, it will be faster to precompute transposes of A_list and pass them to hadamard_sum_ATr!.\n\n\n\n\n\n","category":"method"},{"location":"#FluxDiffUtils.hadamard_sum_ATr!-Union{Tuple{Fxn}, Tuple{Any,Any,Fxn,Any,Vararg{Any,N} where N}} where Fxn","page":"Home","title":"FluxDiffUtils.hadamard_sum_ATr!","text":"hadamard_sum_ATr!(rhs,ATr_list,F,u,Fargs...; skip_index=(i,j)->false)\nhadamard_sum_ATr!(rhs,ATr_list::NTuple{N,SparseMatrixCSC},F,u,Fargs...) where {N}\nhadamard_sum_ATr!(rhs,ATr::SparseMatrixCSC,F,u,Fargs...)\n\nSame as hadamard_sum except that hadamard_sum_ATr!\n\nassumes ATr_list contains transposed matrices.\naccumulates the result into rhs\n\nSpecializes based on whether ATr_list contains SparseMatrixCSC or general arrays. The SparseMatrixCSC version works best if the matrices in ATr_list have distinct sparsity patterns.\n\n\n\n\n\n","category":"method"},{"location":"#FluxDiffUtils.hadamard_sum_ATr!-Union{Tuple{Fxn}, Tuple{D}, Tuple{N}, Tuple{Union{Tuple{Vararg{T,N}}, StaticArrays.SArray{Tuple{N},T,1,N}} where T,Tuple{Vararg{Array,D}},Fxn,Any,Vararg{Any,N} where N}} where Fxn where D where N","page":"Home","title":"FluxDiffUtils.hadamard_sum_ATr!","text":"hadamard_sum_ATr!(rhs::TupleOrSVector{N},ATr_list::NTuple{D,Array},F::Fxn,u,Fargs...;\n                  skip_index=(i,j)->false) where {N,D,Fxn}\nhadamard_sum_ATr!(rhs::NTupleOrSVector{N},ATr::SparseMatrixCSC,F::Fxn,u,Fargs...) where {N,Fxn}\n\nZero-allocation dense/sparse versions if rhs has a statically inferrable length (e.g., is an NTuple or SVector)\n\n\n\n\n\n","category":"method"}]
}
